<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WW Math Generator (Admin)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 18px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    input, select { padding: 8px; font-size: 16px; }
    .card { background: #f6f6f6; border-radius: 10px; padding: 12px; margin: 10px 0; }
    pre { white-space: pre-wrap; background: #111; color: #eee; padding: 12px; border-radius: 10px; overflow: auto; }
    .small { opacity: 0.8; font-size: 14px; }
    .ok { color: #0a7; font-weight: 700; }
    .bad { color: #c33; font-weight: 700; }
  </style>
</head>
<body>
  <h1>WW Math Generator (Admin)</h1>
  <p class="small">
    This page generates a large question bank and downloads it as <b>questions.json</b>.
    Answers are shown because this is an admin generator tool (quiz UI will hide answers later).
  </p>

  <div class="card">
    <div class="row">
      <label>Per family:
        <input id="perFamily" type="number" min="1" max="5000" value="500">
      </label>

      <label>Difficulty:
        <select id="difficulty">
          <option value="mixed" selected>Mixed</option>
          <option value="easy">Easy</option>
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>

      <label>Question types:
        <select id="qtype">
          <option value="mixed" selected>Mixed</option>
          <option value="conversion">Conversion only</option>
          <option value="formula">Formula only</option>
          <option value="formula+unit">Formula + required unit</option>
        </select>
      </label>

      <button id="btnGenerate">Generate Bank</button>
      <button id="btnDownload" disabled>Download questions.json</button>
    </div>

    <div class="row small">
      <div>Status: <span id="status" class="bad">Idle</span></div>
      <div>Families: <span id="families">0</span></div>
      <div>Target: <span id="target">0</span></div>
      <div>Accepted: <span id="accepted">0</span></div>
      <div>Rejected: <span id="rejected">0</span></div>
      <div>Elapsed: <span id="elapsed">0.0</span>s</div>
    </div>
  </div>

  <div class="card">
    <div class="small">Preview (first 5 questions):</div>
    <pre id="preview">(none)</pre>
  </div>

  <script>
    // =========================
    // Core: utilities
    // =========================
    function rand() { return Math.random(); }
    function pick(arr) { return arr[Math.floor(rand() * arr.length)]; }
    function uid(prefix) { return prefix + "-" + Math.floor(Date.now() * rand()).toString(36); }

    function downloadJSON(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function fmt(n, decimals=2) {
      if (!Number.isFinite(n)) return String(n);
      const s = n.toFixed(decimals).replace(/\.?0+$/, "");
      return s;
    }

    // =========================
    // Formula registry (we will fill this next)
    // Each family must implement:
    // - family: string
    // - generate(opts) => { question, answer, difficulty, type, meta }
    // =========================
const FORMULAS = [
  // -------------------------
  // Helpers for this batch
  // -------------------------
{
  family: "Detention Time",
  generate: (opts) => {
    const type =
      (opts.qtype && opts.qtype !== "mixed")
        ? opts.qtype
        : pick(["formula", "formula+unit"]);

    const difficulty =
      (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

    // Decide unit system (US or Metric)
    const unitsMode =
      (opts.unitsMode === "us" || opts.unitsMode === "metric")
        ? opts.unitsMode
        : pick(["us", "metric"]);

    let question, answer;

    if (unitsMode === "us") {
      // ---------- US VERSION ----------
      const flowMGD =
        +(rand() * (difficulty === "hard" ? 15 : difficulty === "normal" ? 8 : 4) + 0.5).toFixed(2);

      const volumeMG =
        +(rand() * (difficulty === "hard" ? 60 : difficulty === "normal" ? 25 : 12) + 1).toFixed(2);

      const dtDays = volumeMG / flowMGD;

      const outUnit =
        (type === "formula+unit") ? pick(["days", "hours"]) : "days";

      const value =
        (outUnit === "hours") ? dtDays * 24 : dtDays;

      question =
        `A plant has a flow of ${flowMGD} MGD and a basin volume of ${volumeMG} MG.\n\n` +
        `What is the detention time in ${outUnit}?`;

      answer = `${fmt(value, 2)} ${outUnit}`;
    } else {
      // ---------- METRIC VERSION ----------
      const flow_m3_day =
        Math.round(rand() * (difficulty === "hard" ? 60000 : difficulty === "normal" ? 30000 : 15000) + 2000);

      const volume_m3 =
        Math.round(rand() * (difficulty === "hard" ? 400000 : difficulty === "normal" ? 200000 : 100000) + 5000);

      const dtDays = volume_m3 / flow_m3_day;

      const outUnit =
        (type === "formula+unit") ? pick(["days", "hours"]) : "days";

      const value =
        (outUnit === "hours") ? dtDays * 24 : dtDays;

      question =
        `A process has a flow of ${flow_m3_day.toLocaleString()} m³/day ` +
        `and a volume of ${volume_m3.toLocaleString()} m³.\n\n` +
        `What is the detention time in ${outUnit}?`;

      answer = `${fmt(value, 2)} ${outUnit}`;
    }

    return {
      type,
      difficulty,
      question,
      answer,
      meta: { unitsMode }
    };
  }


  {
    family: "Mass Loading (lb/day)",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const conc = Math.round(rand() * (difficulty === "hard" ? 600 : difficulty === "normal" ? 350 : 200) + 50); // mg/L
      const flow = +(rand() * (difficulty === "hard" ? 20 : difficulty === "normal" ? 8 : 5) + 0.5).toFixed(2);   // MGD

      // lb/day = mg/L * MGD * 8.34
      const lbsDay = conc * flow * 8.34;

      const questionUnit = (type === "formula+unit") ? "lb/day" : "lb/day";
      const answer = `${fmt(lbsDay, 1)} ${questionUnit}`;

      // occasional irrelevant info (annoying but feasible)
      const extra = (rand() < 0.25)
        ? `\n\nAdditional info (not needed): Temperature is ${Math.round(rand()*30+50)} F.`
        : "";

      const question =
        `An influent concentration is ${conc} mg/L and the flow is ${flow} MGD.\n\n` +
        `What is the mass loading in ${questionUnit}?` + extra;

      return { type, difficulty, question, answer, meta: { conc_mgL: conc, flow_MGD: flow } };
    }
  },

  // -------------------------
  // Conversion-only family
  // -------------------------
  {
    family: "Flow & Volume Conversions",
    generate: (opts) => {
      const type = "conversion";
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const conversions = [
        { from: "MGD", to: "gpm", fn: (v) => (v * 1_000_000) / 1440 },
        { from: "gpm", to: "MGD", fn: (v) => (v * 1440) / 1_000_000 },
        { from: "gpd", to: "MGD", fn: (v) => v / 1_000_000 },
        { from: "MGD", to: "gpd", fn: (v) => v * 1_000_000 },
        { from: "MG",  to: "gal", fn: (v) => v * 1_000_000 },
        { from: "gal", to: "MG",  fn: (v) => v / 1_000_000 }
      ];

      const c = pick(conversions);

      // make "nice" numbers to avoid crazy outputs
      let value;
      if (c.from === "MGD") value = +(rand() * (difficulty === "hard" ? 25 : 10) + 0.25).toFixed(2);
      else if (c.from === "gpm") value = Math.round(rand() * (difficulty === "hard" ? 30_000 : 10_000) + 100);
      else if (c.from === "gpd") value = Math.round(rand() * (difficulty === "hard" ? 30_000_000 : 10_000_000) + 50_000);
      else if (c.from === "MG")  value = +(rand() * (difficulty === "hard" ? 150 : 50) + 0.1).toFixed(2);
      else if (c.from === "gal") value = Math.round(rand() * (difficulty === "hard" ? 80_000_000 : 20_000_000) + 10_000);
      else value = +(rand() * 10 + 1).toFixed(2);

      const result = c.fn(value);

      // rounding rule: conversions can be whole or 2 decimals depending on magnitude
      const decimals = Math.abs(result) < 100 ? 2 : 1;
      const answer = `${fmt(result, decimals)} ${c.to}`;

      const question =
        `Convert ${value} ${c.from} to ${c.to}.`;

      return { type, difficulty, question, answer, meta: { from: c.from, to: c.to, value } };
    }
  }
    ,
  // =========================
  // Batch 2 – Process Control
  // =========================
<label>Units:
  <select id="unitsMode">
    <option value="mixed50" selected>Mixed (50/50)</option>
    <option value="us">US only</option>
    <option value="metric">Metric only</option>
  </select>
</label>

  {
    family: "F/M Ratio",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const bodLoad =
        +(rand() * (difficulty === "hard" ? 6000 : difficulty === "normal" ? 3000 : 1500) + 300).toFixed(0); // lb/day
      const mlvss =
        +(rand() * (difficulty === "hard" ? 25000 : difficulty === "normal" ? 12000 : 6000) + 1000).toFixed(0); // lb

      const fm = bodLoad / mlvss;

      const question =
        `A plant has a 5-day BOD loading of ${bodLoad} lb/day and an MLVSS of ${mlvss} lb.\n\n` +
        `What is the F/M ratio?`;

      const answer = `${fmt(fm, 3)}`;

      return { type, difficulty, question, answer, meta: { bodLoad, mlvss } };
    }
  },

  {
    family: "Solids Retention Time (SRT)",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const totalSolids =
        +(rand() * (difficulty === "hard" ? 80000 : difficulty === "normal" ? 40000 : 20000) + 2000).toFixed(0); // lb
      const solidsWasted =
        +(rand() * (difficulty === "hard" ? 8000 : difficulty === "normal" ? 4000 : 1500) + 200).toFixed(0); // lb/day

      const srt = totalSolids / solidsWasted;

      const question =
        `A system contains ${totalSolids} lb of solids and wastes ${solidsWasted} lb/day.\n\n` +
        `What is the solids retention time (days)?`;

      const answer = `${fmt(srt, 2)} days`;

      return { type, difficulty, question, answer, meta: { totalSolids, solidsWasted } };
    }
  },

  {
    family: "Sludge Volume Index (SVI)",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const settleVol =
        +(rand() * (difficulty === "hard" ? 400 : difficulty === "normal" ? 250 : 150) + 50).toFixed(0); // mL/L
      const mlss =
        +(rand() * (difficulty === "hard" ? 6000 : difficulty === "normal" ? 4000 : 2500) + 1000).toFixed(0); // mg/L

      const svi = (settleVol / mlss) * 1000;

      const question =
        `A sludge settles to ${settleVol} mL/L after 30 minutes and the MLSS is ${mlss} mg/L.\n\n` +
        `What is the sludge volume index (SVI)?`;

      const answer = `${fmt(svi, 1)} mL/g`;

      return { type, difficulty, question, answer, meta: { settleVol, mlss } };
    }
  },

  {
    family: "Flow Velocity",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const flow =
        +(rand() * (difficulty === "hard" ? 20 : difficulty === "normal" ? 10 : 5) + 0.5).toFixed(2); // cfs
      const area =
        +(rand() * (difficulty === "hard" ? 20 : difficulty === "normal" ? 10 : 4) + 0.5).toFixed(2); // ft²

      const velocity = flow / area;

      const question =
        `A channel has a flow of ${flow} ft³/sec and a cross-sectional area of ${area} ft².\n\n` +
        `What is the flow velocity in ft/sec?`;

      const answer = `${fmt(velocity, 2)} ft/sec`;

      return { type, difficulty, question, answer, meta: { flow, area } };
    }
  }
  ,
  // =========================
  // Batch 3 – Clarifier Rates
  // =========================

  {
    family: "Surface Overflow Rate (SOR)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const flowMGD =
        +(rand() * (difficulty === "hard" ? 25 : difficulty === "normal" ? 12 : 6) + 0.5).toFixed(2);
      const areaFt2 =
        Math.round(rand() * (difficulty === "hard" ? 12000 : difficulty === "normal" ? 6000 : 3000) + 500);

      const gpd = flowMGD * 1_000_000;
      const sor = gpd / areaFt2;

      const question =
        `A clarifier treats ${flowMGD} MGD and has a surface area of ${areaFt2} ft².\n\n` +
        `What is the surface overflow rate (gpd/ft²)?`;

      const answer = `${fmt(sor, 0)} gpd/ft²`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { flowMGD, areaFt2 }
      };
    }
  },

  {
    family: "Weir Overflow Rate (WOR)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const flowMGD =
        +(rand() * (difficulty === "hard" ? 25 : difficulty === "normal" ? 12 : 6) + 0.5).toFixed(2);
      const weirFt =
        Math.round(rand() * (difficulty === "hard" ? 1200 : difficulty === "normal" ? 700 : 350) + 100);

      const gpd = flowMGD * 1_000_000;
      const wor = gpd / weirFt;

      const question =
        `A clarifier receives ${flowMGD} MGD and has a total weir length of ${weirFt} ft.\n\n` +
        `What is the weir overflow rate (gpd/ft)?`;

      const answer = `${fmt(wor, 0)} gpd/ft`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { flowMGD, weirFt }
      };
    }
  },

  {
    family: "Solids Loading Rate (SLR)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const solidsLbDay =
        Math.round(rand() * (difficulty === "hard" ? 40000 : difficulty === "normal" ? 20000 : 8000) + 2000);
      const areaFt2 =
        Math.round(rand() * (difficulty === "hard" ? 12000 : difficulty === "normal" ? 6000 : 3000) + 500);

      const slr = solidsLbDay / areaFt2;

      const question =
        `A clarifier receives ${solidsLbDay} lb/day of solids and has a surface area of ${areaFt2} ft².\n\n` +
        `What is the solids loading rate (lb/day/ft²)?`;

      const answer = `${fmt(slr, 2)} lb/day/ft²`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { solidsLbDay, areaFt2 }
      };
    }
  }
  ,
  // =========================
  // Batch 4 – Pumps & Electrical
  // =========================

  {
    family: "Pump Power (HP)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const flowGPM =
        Math.round(rand() * (difficulty === "hard" ? 6000 : difficulty === "normal" ? 3000 : 1500) + 200);
      const headFt =
        Math.round(rand() * (difficulty === "hard" ? 180 : difficulty === "normal" ? 120 : 60) + 20);
      const efficiency =
        +(rand() * (difficulty === "hard" ? 0.25 : difficulty === "normal" ? 0.20 : 0.15) + 0.65).toFixed(2);

      // HP = (Q * H) / (3960 * eff)
      const hp = (flowGPM * headFt) / (3960 * efficiency);

      const question =
        `A pump delivers ${flowGPM} gpm against a head of ${headFt} ft ` +
        `with an efficiency of ${(efficiency * 100).toFixed(0)}%.\n\n` +
        `What is the required pump horsepower?`;

      const answer = `${fmt(hp, 2)} HP`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { flowGPM, headFt, efficiency }
      };
    }
  },

  {
    family: "Electrical Power (kW)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const volts =
        Math.round(rand() * (difficulty === "hard" ? 460 : difficulty === "normal" ? 240 : 120) + 120);
      const amps =
        +(rand() * (difficulty === "hard" ? 150 : difficulty === "normal" ? 80 : 40) + 5).toFixed(1);
      const phases = pick([1, 3]);
      const pf =
        +(rand() * (difficulty === "hard" ? 0.25 : difficulty === "normal" ? 0.20 : 0.15) + 0.75).toFixed(2);

      // kW = (V * I * √3 * PF) / 1000 for 3-phase, else (V * I * PF) / 1000
      const kw = phases === 3
        ? (volts * amps * 1.732 * pf) / 1000
        : (volts * amps * pf) / 1000;

      const phaseText = phases === 3 ? "three-phase" : "single-phase";

      const question =
        `A ${phaseText} motor operates at ${volts} volts and draws ${amps} amps ` +
        `with a power factor of ${pf}.\n\n` +
        `What is the electrical power in kW?`;

      const answer = `${fmt(kw, 2)} kW`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { volts, amps, phases, pf }
      };
    }
  },

  {
    family: "Energy Use (kWh/day)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const kw =
        +(rand() * (difficulty === "hard" ? 250 : difficulty === "normal" ? 120 : 60) + 5).toFixed(1);
      const hours =
        Math.round(rand() * (difficulty === "hard" ? 24 : difficulty === "normal" ? 16 : 12) + 1);

      const kwhDay = kw * hours;

      const question =
        `A piece of equipment operates at ${kw} kW for ${hours} hours per day.\n\n` +
        `What is the daily energy use in kWh/day?`;

      const answer = `${fmt(kwhDay, 1)} kWh/day`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { kw, hours }
      };
    }
  }
  ,
  // =========================
  // Batch 5 – Lab & Chemistry
  // =========================

  {
    family: "BOD (Unseeded)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const initialDO =
        +(rand() * (difficulty === "hard" ? 8 : 6) + 2).toFixed(1);
      const finalDO =
        +(rand() * (difficulty === "hard" ? 2 : 1.5) + 0.2).toFixed(1);
      const sampleML =
        pick([10, 15, 20, 25, 50]);

      const bod = ((initialDO - finalDO) * 300) / sampleML;

      const question =
        `An unseeded BOD test has an initial DO of ${initialDO} mg/L ` +
        `and a final DO of ${finalDO} mg/L using a ${sampleML} mL sample.\n\n` +
        `What is the BOD in mg/L?`;

      const answer = `${fmt(bod, 1)} mg/L`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { initialDO, finalDO, sampleML }
      };
    }
  },

  {
    family: "BOD (Seeded)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const initialDO =
        +(rand() * (difficulty === "hard" ? 8 : 6) + 2).toFixed(1);
      const finalDO =
        +(rand() * (difficulty === "hard" ? 2 : 1.5) + 0.2).toFixed(1);
      const seedCorrection =
        +(rand() * (difficulty === "hard" ? 1.5 : 1.0) + 0.1).toFixed(2);
      const sampleML =
        pick([10, 15, 20, 25, 50]);

      const bod = ((initialDO - finalDO - seedCorrection) * 300) / sampleML;

      const question =
        `A seeded BOD test has an initial DO of ${initialDO} mg/L, ` +
        `a final DO of ${finalDO} mg/L, and a seed correction of ${seedCorrection} mg/L ` +
        `using a ${sampleML} mL sample.\n\n` +
        `What is the BOD in mg/L?`;

      const answer = `${fmt(bod, 1)} mg/L`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { initialDO, finalDO, seedCorrection, sampleML }
      };
    }
  },

  {
    family: "Alkalinity (as CaCO₃)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const acidML =
        +(rand() * (difficulty === "hard" ? 25 : 15) + 5).toFixed(1);
      const normality =
        pick([0.02, 0.05, 0.1]);
      const sampleML =
        pick([50, 100, 200]);

      // mg/L as CaCO3 = (mL acid * N * 50,000) / mL sample
      const alk = (acidML * normality * 50000) / sampleML;

      const question =
        `A ${sampleML} mL sample requires ${acidML} mL of ${normality} N acid.\n\n` +
        `What is the alkalinity as CaCO₃ (mg/L)?`;

      const answer = `${fmt(alk, 0)} mg/L as CaCO₃`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { acidML, normality, sampleML }
      };
    }
  },

  {
    family: "Dissolved Oxygen Deficit",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const saturationDO =
        +(rand() * (difficulty === "hard" ? 10 : 8) + 6).toFixed(1);
      const actualDO =
        +(rand() * (difficulty === "hard" ? 4 : 3) + 0.5).toFixed(1);

      const deficit = saturationDO - actualDO;

      const question =
        `The DO saturation is ${saturationDO} mg/L and the measured DO is ${actualDO} mg/L.\n\n` +
        `What is the dissolved oxygen deficit?`;

      const answer = `${fmt(deficit, 1)} mg/L`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { saturationDO, actualDO }
      };
    }
  }
  ,
  // =========================
  // Batch 6 – Filters & Backwash
  // =========================

  {
    family: "Filter Backwash Rate",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const areaFt2 =
        Math.round(rand() * (difficulty === "hard" ? 1200 : difficulty === "normal" ? 600 : 300) + 50);
      const flowGPM =
        Math.round(rand() * (difficulty === "hard" ? 2500 : difficulty === "normal" ? 1500 : 800) + 200);

      const rate = flowGPM / areaFt2;

      const units = pick(["gpm/ft²", "L/m²·min"]);
      const answerValue = units === "gpm/ft²"
        ? rate
        : rate * 40.74; // gpm/ft² → L/m²·min

      const question =
        `A filter has an area of ${areaFt2} ft² and is backwashed at ${flowGPM} gpm.\n\n` +
        `What is the backwash rate in ${units}?`;

      const answer = `${fmt(answerValue, 2)} ${units}`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { areaFt2, flowGPM }
      };
    }
  },

  {
    family: "Filter Backwash Rise Rate",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const expansionIn =
        +(rand() * (difficulty === "hard" ? 18 : difficulty === "normal" ? 12 : 8) + 2).toFixed(1);
      const timeMin =
        Math.round(rand() * (difficulty === "hard" ? 15 : difficulty === "normal" ? 10 : 6) + 2);

      const rateInMin = expansionIn / timeMin;

      const units = pick(["in/min", "cm/min"]);
      const answerValue = units === "in/min"
        ? rateInMin
        : rateInMin * 2.54;

      const question =
        `A filter bed expands ${expansionIn} inches in ${timeMin} minutes during backwash.\n\n` +
        `What is the rise rate in ${units}?`;

      const answer = `${fmt(answerValue, 2)} ${units}`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { expansionIn, timeMin }
      };
    }
  },

  {
    family: "Filter Yield",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const massLb =
        Math.round(rand() * (difficulty === "hard" ? 12000 : difficulty === "normal" ? 6000 : 3000) + 500);
      const areaFt2 =
        Math.round(rand() * (difficulty === "hard" ? 1000 : difficulty === "normal" ? 500 : 250) + 50);
      const hours =
        Math.round(rand() * (difficulty === "hard" ? 12 : difficulty === "normal" ? 8 : 6) + 1);

      const rateLb = massLb / (areaFt2 * hours);

      const units = pick(["lb/hr/ft²", "kg/hr/m²"]);
      const answerValue = units === "lb/hr/ft²"
        ? rateLb
        : rateLb * 4.882; // lb/ft²·hr → kg/m²·hr

      const question =
        `A filter produces ${massLb} lb of solids over ${hours} hours ` +
        `with an area of ${areaFt2} ft².\n\n` +
        `What is the filter yield in ${units}?`;

      const answer = `${fmt(answerValue, 3)} ${units}`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { massLb, areaFt2, hours }
      };
    }
  },

  {
    family: "Hydraulic Loading (Areal)",
    generate: (opts) => {
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed")
        ? opts.difficulty
        : pick(["easy", "normal", "hard"]);

      const flowMGD =
        +(rand() * (difficulty === "hard" ? 25 : difficulty === "normal" ? 12 : 6) + 0.5).toFixed(2);
      const areaFt2 =
        Math.round(rand() * (difficulty === "hard" ? 12000 : difficulty === "normal" ? 6000 : 3000) + 500);

      const gpd = flowMGD * 1_000_000;
      const loading = gpd / areaFt2;

      const units = pick(["gpd/ft²", "gpd/m²"]);
      const answerValue = units === "gpd/ft²"
        ? loading
        : loading * 10.764;

      const question =
        `A process treats ${flowMGD} MGD with a surface area of ${areaFt2} ft².\n\n` +
        `What is the hydraulic loading rate in ${units}?`;

      const answer = `${fmt(answerValue, 0)} ${units}`;

      return {
        type: "formula+unit",
        difficulty,
        question,
        answer,
        meta: { flowMGD, areaFt2 }
      };
    }
  }
  ,
  // =========================
  // Batch 7 – Experimental / Edge
  // =========================

  {
    family: "Weir Flow (Experimental)",
    generate: () => {
      const lengthFt = +(rand() * 20 + 2).toFixed(1);
      const headFt = +(rand() * 1.2 + 0.2).toFixed(2);

      // Q = 3.33 * L * H^(3/2)
      const flowCFS = 3.33 * lengthFt * Math.pow(headFt, 1.5);

      const question =
        `A rectangular weir has a crest length of ${lengthFt} ft ` +
        `and a head of ${headFt} ft.\n\n` +
        `Estimate the flow rate in ft³/sec. (Experimental)`;

      const answer = `${fmt(flowCFS, 2)} ft³/sec`;

      return {
        type: "formula+unit",
        difficulty: "hard",
        question,
        answer,
        meta: { lengthFt, headFt, experimental: true }
      };
    }
  },

  {
    family: "Multi-Step Conversion",
    generate: () => {
      const flowMGD = +(rand() * 8 + 1).toFixed(2);

      // MGD → gpd → gpm
      const gpd = flowMGD * 1_000_000;
      const gpm = gpd / 1440;

      const question =
        `A plant treats ${flowMGD} MGD.\n\n` +
        `Convert this flow to gallons per minute (gpm).`;

      const answer = `${fmt(gpm, 1)} gpm`;

      return {
        type: "conversion",
        difficulty: "normal",
        question,
        answer,
        meta: { flowMGD }
      };
    }
  },

  {
    family: "Generic Detention Time (Any Volume)",
    generate: () => {
      const volumeGal =
        Math.round(rand() * 8_000_000 + 500_000);
      const flowGPM =
        Math.round(rand() * 6000 + 300);

      const volumeGalPerMin = flowGPM;
      const minutes = volumeGal / volumeGalPerMin;
      const hours = minutes / 60;

      const question =
        `A process unit has a volume of ${volumeGal.toLocaleString()} gallons ` +
        `and a flow of ${flowGPM} gpm.\n\n` +
        `What is the detention time in hours?`;

      const answer = `${fmt(hours, 2)} hours`;

      return {
        type: "formula+unit",
        difficulty: "normal",
        question,
        answer,
        meta: { volumeGal, flowGPM }
      };
    }
  },

  {
    family: "Extra Information Stress Question",
    generate: () => {
      const flowMGD = +(rand() * 6 + 1).toFixed(2);
      const areaFt2 = Math.round(rand() * 4000 + 800);
      const tempF = Math.round(rand() * 40 + 45); // irrelevant
      const ph = +(rand() * 1.5 + 6.5).toFixed(1); // irrelevant

      const gpd = flowMGD * 1_000_000;
      const loading = gpd / areaFt2;

      const question =
        `A clarifier treats ${flowMGD} MGD and has an area of ${areaFt2} ft².\n` +
        `The wastewater temperature is ${tempF}°F and the pH is ${ph}.\n\n` +
        `What is the surface loading rate (gpd/ft²)?`;

      const answer = `${fmt(loading, 0)} gpd/ft²`;

      return {
        type: "formula+unit",
        difficulty: "hard",
        question,
        answer,
        meta: { flowMGD, areaFt2, tempF, ph }
      };
    }
  }

];

    // =========================
    // Generator engine
    // =========================
    let BANK = null;

    async function generateBank() {
      const perFamily = Number(document.getElementById("perFamily").value || 500);
      const difficulty = document.getElementById("difficulty").value;
      const qtype = document.getElementById("qtype").value;

      const status = document.getElementById("status");
      const familiesEl = document.getElementById("families");
      const targetEl = document.getElementById("target");
      const acceptedEl = document.getElementById("accepted");
      const rejectedEl = document.getElementById("rejected");
      const elapsedEl = document.getElementById("elapsed");
      const previewEl = document.getElementById("preview");
      const btnDownload = document.getElementById("btnDownload");

      BANK = null;
      btnDownload.disabled = true;

      const start = performance.now();
      status.textContent = "Generating...";
      status.className = "ok";

      const families = FORMULAS.map(f => f.family);
      familiesEl.textContent = String(families.length);
      targetEl.textContent = String(families.length * perFamily);

      const out = {
        generated_at: new Date().toISOString(),
        settings: { perFamily, difficulty, qtype },
        families,
        questions: []
      };

      let accepted = 0;
      let rejected = 0;

      // Cap attempts so we never infinite loop if a family is too strict.
      const MAX_ATTEMPTS_PER_FAMILY = perFamily * 50;

for (const fam of FORMULAS) {
  let got = 0;
  let attempts = 0;

  // exact split per family when mixed50
  const targetUS = (unitsMode === "mixed50") ? Math.floor(perFamily / 2) : perFamily;
  const targetMetric = (unitsMode === "mixed50") ? (perFamily - targetUS) : perFamily;

  let gotUS = 0;
  let gotMetric = 0;

  while (got < perFamily && attempts < MAX_ATTEMPTS_PER_FAMILY) {
    attempts++;

    // Decide which unit system we still need MORE of
    let forcedUnitsMode = unitsMode;
    if (unitsMode === "mixed50") {
      forcedUnitsMode = (gotUS < targetUS) ? "us" : "metric";
    }

    const q = fam.generate({ difficulty, qtype, unitsMode: forcedUnitsMode });

    // existing filters
    if (qtype !== "mixed" && q.type !== qtype) { rejected++; continue; }
    if (difficulty !== "mixed" && q.difficulty !== difficulty) { rejected++; continue; }
    if (!q.question || !q.answer) { rejected++; continue; }

    out.questions.push({
      id: uid(fam.family.replace(/\s+/g, "_")),
      family: fam.family,
      type: q.type,
      difficulty: q.difficulty,
      units_mode: forcedUnitsMode,          // <— store it
      question: q.question,
      answer: q.answer,
      meta: q.meta || {}
    });

    got++;
    accepted++;

    if (unitsMode === "mixed50") {
      if (forcedUnitsMode === "us") gotUS++;
      else gotMetric++;
    }

    // (your existing UI update / await breathing stays the same)
  }
}


          // Filters (we’ll make these smarter later)
          if (qtype !== "mixed" && q.type !== qtype) { rejected++; continue; }
          if (difficulty !== "mixed" && q.difficulty !== difficulty) { rejected++; continue; }

          // Basic sanity: must have question+answer
          if (!q.question || !q.answer) { rejected++; continue; }

          out.questions.push({
            id: uid(fam.family.replace(/\s+/g, "_")),
            family: fam.family,
            type: q.type,
            difficulty: q.difficulty,
            question: q.question,
            answer: q.answer,
            meta: q.meta || {}
          });

          got++;
          accepted++;
          if (accepted % 100 === 0) {
            acceptedEl.textContent = String(accepted);
            rejectedEl.textContent = String(rejected);
            elapsedEl.textContent = ((performance.now() - start)/1000).toFixed(1);
            await new Promise(r => setTimeout(r, 0)); // allow UI to breathe
          }
        }

        acceptedEl.textContent = String(accepted);
        rejectedEl.textContent = String(rejected);
        elapsedEl.textContent = ((performance.now() - start)/1000).toFixed(1);
      }

      BANK = out;
      btnDownload.disabled = false;

      previewEl.textContent = JSON.stringify(out.questions.slice(0, 5), null, 2);
      status.textContent = "Done";
      status.className = "ok";
    }

    // =========================
    // Wire UI
    // =========================
    document.getElementById("btnGenerate").addEventListener("click", () => {
      generateBank().catch(e => {
        console.error(e);
        const status = document.getElementById("status");
        status.textContent = "ERROR: " + (e?.message || e);
        status.className = "bad";
      });
    });

    document.getElementById("btnDownload").addEventListener("click", () => {
      if (!BANK) return;
      downloadJSON("questions.json", BANK);
    });
  </script>
</body>
</html>

