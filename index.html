<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WW Math Generator (Admin)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 18px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    input, select { padding: 8px; font-size: 16px; }
    .card { background: #f6f6f6; border-radius: 10px; padding: 12px; margin: 10px 0; }
    pre { white-space: pre-wrap; background: #111; color: #eee; padding: 12px; border-radius: 10px; overflow: auto; }
    .small { opacity: 0.8; font-size: 14px; }
    .ok { color: #0a7; font-weight: 700; }
    .bad { color: #c33; font-weight: 700; }
  </style>
</head>
<body>
  <h1>WW Math Generator (Admin)</h1>
  <p class="small">
    This page generates a large question bank and downloads it as <b>questions.json</b>.
    Answers are shown because this is an admin generator tool (quiz UI will hide answers later).
  </p>

  <div class="card">
    <div class="row">
      <label>Per family:
        <input id="perFamily" type="number" min="1" max="5000" value="500">
      </label>

      <label>Difficulty:
        <select id="difficulty">
          <option value="mixed" selected>Mixed</option>
          <option value="easy">Easy</option>
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>

      <label>Question types:
        <select id="qtype">
          <option value="mixed" selected>Mixed</option>
          <option value="conversion">Conversion only</option>
          <option value="formula">Formula only</option>
          <option value="formula+unit">Formula + required unit</option>
        </select>
      </label>

      <button id="btnGenerate">Generate Bank</button>
      <button id="btnDownload" disabled>Download questions.json</button>
    </div>

    <div class="row small">
      <div>Status: <span id="status" class="bad">Idle</span></div>
      <div>Families: <span id="families">0</span></div>
      <div>Target: <span id="target">0</span></div>
      <div>Accepted: <span id="accepted">0</span></div>
      <div>Rejected: <span id="rejected">0</span></div>
      <div>Elapsed: <span id="elapsed">0.0</span>s</div>
    </div>
  </div>

  <div class="card">
    <div class="small">Preview (first 5 questions):</div>
    <pre id="preview">(none)</pre>
  </div>

  <script>
    // =========================
    // Core: utilities
    // =========================
    function rand() { return Math.random(); }
    function pick(arr) { return arr[Math.floor(rand() * arr.length)]; }
    function uid(prefix) { return prefix + "-" + Math.floor(Date.now() * rand()).toString(36); }

    function downloadJSON(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function fmt(n, decimals=2) {
      if (!Number.isFinite(n)) return String(n);
      const s = n.toFixed(decimals).replace(/\.?0+$/, "");
      return s;
    }

    // =========================
    // Formula registry (we will fill this next)
    // Each family must implement:
    // - family: string
    // - generate(opts) => { question, answer, difficulty, type, meta }
    // =========================
const FORMULAS = [
  // -------------------------
  // Helpers for this batch
  // -------------------------
  {
    family: "Detention Time",
    generate: (opts) => {
      // pick type
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      // difficulty affects ranges a bit
      const flowMGD = +(rand() * (difficulty === "hard" ? 15 : difficulty === "normal" ? 8 : 4) + 0.5).toFixed(2);
      const volumeMG = +(rand() * (difficulty === "hard" ? 60 : difficulty === "normal" ? 25 : 12) + 1).toFixed(2);

      // DT (days) = V(MG) / Q(MGD)
      const dtDays = volumeMG / flowMGD;

      let questionUnit = "days";
      if (type === "formula+unit") questionUnit = pick(["days", "hours"]);

      const answerValue = (questionUnit === "hours") ? dtDays * 24 : dtDays;
      const answer = `${fmt(answerValue, 2)} ${questionUnit}`;

      const question =
        `A plant has a flow of ${flowMGD} MGD and a basin volume of ${volumeMG} MG.\n\n` +
        `What is the detention time in ${questionUnit}?`;

      return { type, difficulty, question, answer, meta: { flowMGD, volumeMG } };
    }
  },

  {
    family: "Mass Loading (lb/day)",
    generate: (opts) => {
      const type = (opts.qtype && opts.qtype !== "mixed") ? opts.qtype : pick(["formula", "formula+unit"]);
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const conc = Math.round(rand() * (difficulty === "hard" ? 600 : difficulty === "normal" ? 350 : 200) + 50); // mg/L
      const flow = +(rand() * (difficulty === "hard" ? 20 : difficulty === "normal" ? 8 : 5) + 0.5).toFixed(2);   // MGD

      // lb/day = mg/L * MGD * 8.34
      const lbsDay = conc * flow * 8.34;

      const questionUnit = (type === "formula+unit") ? "lb/day" : "lb/day";
      const answer = `${fmt(lbsDay, 1)} ${questionUnit}`;

      // occasional irrelevant info (annoying but feasible)
      const extra = (rand() < 0.25)
        ? `\n\nAdditional info (not needed): Temperature is ${Math.round(rand()*30+50)} F.`
        : "";

      const question =
        `An influent concentration is ${conc} mg/L and the flow is ${flow} MGD.\n\n` +
        `What is the mass loading in ${questionUnit}?` + extra;

      return { type, difficulty, question, answer, meta: { conc_mgL: conc, flow_MGD: flow } };
    }
  },

  // -------------------------
  // Conversion-only family
  // -------------------------
  {
    family: "Flow & Volume Conversions",
    generate: (opts) => {
      const type = "conversion";
      const difficulty = (opts.difficulty && opts.difficulty !== "mixed") ? opts.difficulty : pick(["easy", "normal", "hard"]);

      const conversions = [
        { from: "MGD", to: "gpm", fn: (v) => (v * 1_000_000) / 1440 },
        { from: "gpm", to: "MGD", fn: (v) => (v * 1440) / 1_000_000 },
        { from: "gpd", to: "MGD", fn: (v) => v / 1_000_000 },
        { from: "MGD", to: "gpd", fn: (v) => v * 1_000_000 },
        { from: "MG",  to: "gal", fn: (v) => v * 1_000_000 },
        { from: "gal", to: "MG",  fn: (v) => v / 1_000_000 }
      ];

      const c = pick(conversions);

      // make "nice" numbers to avoid crazy outputs
      let value;
      if (c.from === "MGD") value = +(rand() * (difficulty === "hard" ? 25 : 10) + 0.25).toFixed(2);
      else if (c.from === "gpm") value = Math.round(rand() * (difficulty === "hard" ? 30_000 : 10_000) + 100);
      else if (c.from === "gpd") value = Math.round(rand() * (difficulty === "hard" ? 30_000_000 : 10_000_000) + 50_000);
      else if (c.from === "MG")  value = +(rand() * (difficulty === "hard" ? 150 : 50) + 0.1).toFixed(2);
      else if (c.from === "gal") value = Math.round(rand() * (difficulty === "hard" ? 80_000_000 : 20_000_000) + 10_000);
      else value = +(rand() * 10 + 1).toFixed(2);

      const result = c.fn(value);

      // rounding rule: conversions can be whole or 2 decimals depending on magnitude
      const decimals = Math.abs(result) < 100 ? 2 : 1;
      const answer = `${fmt(result, decimals)} ${c.to}`;

      const question =
        `Convert ${value} ${c.from} to ${c.to}.`;

      return { type, difficulty, question, answer, meta: { from: c.from, to: c.to, value } };
    }
  }
];

    // =========================
    // Generator engine
    // =========================
    let BANK = null;

    async function generateBank() {
      const perFamily = Number(document.getElementById("perFamily").value || 500);
      const difficulty = document.getElementById("difficulty").value;
      const qtype = document.getElementById("qtype").value;

      const status = document.getElementById("status");
      const familiesEl = document.getElementById("families");
      const targetEl = document.getElementById("target");
      const acceptedEl = document.getElementById("accepted");
      const rejectedEl = document.getElementById("rejected");
      const elapsedEl = document.getElementById("elapsed");
      const previewEl = document.getElementById("preview");
      const btnDownload = document.getElementById("btnDownload");

      BANK = null;
      btnDownload.disabled = true;

      const start = performance.now();
      status.textContent = "Generating...";
      status.className = "ok";

      const families = FORMULAS.map(f => f.family);
      familiesEl.textContent = String(families.length);
      targetEl.textContent = String(families.length * perFamily);

      const out = {
        generated_at: new Date().toISOString(),
        settings: { perFamily, difficulty, qtype },
        families,
        questions: []
      };

      let accepted = 0;
      let rejected = 0;

      // Cap attempts so we never infinite loop if a family is too strict.
      const MAX_ATTEMPTS_PER_FAMILY = perFamily * 50;

      for (const fam of FORMULAS) {
        let got = 0;
        let attempts = 0;

        while (got < perFamily && attempts < MAX_ATTEMPTS_PER_FAMILY) {
          attempts++;

          const q = fam.generate({ difficulty, qtype });

          // Filters (weâ€™ll make these smarter later)
          if (qtype !== "mixed" && q.type !== qtype) { rejected++; continue; }
          if (difficulty !== "mixed" && q.difficulty !== difficulty) { rejected++; continue; }

          // Basic sanity: must have question+answer
          if (!q.question || !q.answer) { rejected++; continue; }

          out.questions.push({
            id: uid(fam.family.replace(/\s+/g, "_")),
            family: fam.family,
            type: q.type,
            difficulty: q.difficulty,
            question: q.question,
            answer: q.answer,
            meta: q.meta || {}
          });

          got++;
          accepted++;
          if (accepted % 100 === 0) {
            acceptedEl.textContent = String(accepted);
            rejectedEl.textContent = String(rejected);
            elapsedEl.textContent = ((performance.now() - start)/1000).toFixed(1);
            await new Promise(r => setTimeout(r, 0)); // allow UI to breathe
          }
        }

        acceptedEl.textContent = String(accepted);
        rejectedEl.textContent = String(rejected);
        elapsedEl.textContent = ((performance.now() - start)/1000).toFixed(1);
      }

      BANK = out;
      btnDownload.disabled = false;

      previewEl.textContent = JSON.stringify(out.questions.slice(0, 5), null, 2);
      status.textContent = "Done";
      status.className = "ok";
    }

    // =========================
    // Wire UI
    // =========================
    document.getElementById("btnGenerate").addEventListener("click", () => {
      generateBank().catch(e => {
        console.error(e);
        const status = document.getElementById("status");
        status.textContent = "ERROR: " + (e?.message || e);
        status.className = "bad";
      });
    });

    document.getElementById("btnDownload").addEventListener("click", () => {
      if (!BANK) return;
      downloadJSON("questions.json", BANK);
    });
  </script>
</body>
</html>

